\name{rPSNCP}
\alias{rPSNCP}
\title{Simulate Product Shot-noise Cox Process}
\description{
  Generate a random multitype point pattern, a realisation of the
  product shot-noise Cox process.
}
\usage{
 rPSNCP(lambda=rep(100, 4), kappa=rep(25, 4), omega=rep(0.03, 4), 
        alpha=matrix(runif(16, -1, 3), nrow=4, ncol=4), 
        kernels=NULL, nu.ker=NULL, win=owin(), nsim=1, names=NULL, 
        eps=NULL, dimyx=NULL, xy=NULL, epsth=0.001, mc.cores=1L)
}
\arguments{
  \item{lambda}{
    List of intensities of component processes. Either a
    numberic vector determining the constant (homogeneous) intensities 
    or a list pixel images (object of class \code{"im"}) determining 
    the (inhomogeneous) intensity functions of  component processes. 
    The length of \code{lambda} determines the number of component processes.
  }
  \item{kappa}{
    Numeric vector of intensities of the Poisson process of cluster centres
    for component processes. Must have the same size as \code{lambda}.
  }
  \item{omega}{
    Numeric vector of bandwidths of cluster dispersal kernels
    for component processes. Must have the same size as \code{lambda} 
    and \code{kappa}.
  }
  \item{alpha}{
    Matrix of interaction parameters. Square numeric matrix with the same 
    number of rows and columns as the length of \code{lambda}, \code{kappa} and \code{omega}.
    All entries of \code{alpha} musb be greater than -1.
  }
  \item{kernels}{
    Vector of character string determining the cluster dispersal kernels
    of component processes. Impleneted kernels are Gaussian 
    kernel (\code{"Thomas"}) with bandwidth \code{omega}, 
    Variance-Gamma (Bessel) kernel (\code{"VarGamma"}) with 
    bandwidth \code{omega} and shape parameter \code{nu.ker} 
    and Cauchy kernel (\code{"Cauchy"}) with bandwidth \code{omega}.
    Must have the same length as \code{lambda}, \code{kappa} and \code{omega}.
  }
  \item{nu.ker}{
    Numeric vector of bandwidths of shape parameters for Varaince-Gamma
    kernels. 
  }
  \item{win}{
    Window in which to simulate the pattern.
    An object of class \code{"owin"}.
  }
  \item{nsim}{Number of simulated realisations to be generated.}
  \item{names}{
    Optional vector of character string indicating names of component processes.
  }
  \item{eps,dimyx,xy}{
    Optional parameters passed to \code{\link{as.mask}}
    which determine the pixel array geometry.
    See \code{\link{as.mask}}.
  \item{\dots}{
    Additional parameters for the covariance,
    or arguments passed to \code{\link{as.mask}} to determine
    the pixel resolution.
  }
  \item{epsth}{
    Numerical threshold to determine the maximum interaction range for 
    cluster kernels. See Details.
  }
  \item{mc.cores}{
    Integer value indicating the number of cores for parallel computing using
    \code{"mclapply"} function in the \pkg{parallel} package.
  }
}
\value{
  A point pattern (an object of class \code{"ppp"}) if \code{nsim=1}, or a
     list of point patterns if \code{nsim > 1}.  Each point pattern is
     multitype (it carries a vector of marks which is a factor).
}
\details{
  This function generates a realisation of a log-Gaussian Cox
  process (LGCP). This is a Cox point process in which
  the logarithm of the random intensity is a Gaussian random
  field with mean function \eqn{\mu} and covariance function
  \eqn{c(r)}. Conditional on the random intensity, the point process
  is a Poisson process with this intensity.

  The string \code{model} specifies the covariance 
  function of the Gaussian random field, and the parameters
  of the covariance are determined by \code{param} and \code{\dots}.

  To determine the covariance model, the string \code{model}
  is prefixed by \code{"RM"}, and a function of this name is
  sought in the \pkg{RandomFields} package. 
  For a list of available models see 
  \code{\link[RandomFields]{RMmodel}} in the
  \pkg{RandomFields} package. For example the
  \Matern covariance is specified by \code{model="matern"}, corresponding
  to the function \code{RMmatern} in the \pkg{RandomFields} package.

  Standard variance parameters (for all functions beginning with
  \code{"RM"} in the \pkg{RandomFields} package) are \code{var}
  for the variance at distance zero, and \code{scale} for the scale
  parameter. Other parameters are specified in the help files
  for the individual functions beginning with \code{"RM"}. For example
  the help file for \code{RMmatern} states that \code{nu} is a parameter
  for this model.

  This algorithm uses the function \code{\link[RandomFields]{RFsimulate}} in the
  \pkg{RandomFields} package to generate values of
  a Gaussian random field, with the specified mean function \code{mu}
  and the covariance specified by the arguments \code{model} and
  \code{param}, on the points of a regular grid. The exponential
  of this random field is taken as the intensity of a Poisson point
  process, and a realisation of the Poisson process is then generated by the 
  function \code{\link{rpoispp}} in the \pkg{spatstat} package.
  
  If the simulation window \code{win} is missing or \code{NULL},
  then it defaults to 
  \code{Window(mu)} if \code{mu} is a pixel image,
  and it defaults to the unit square otherwise.
  
  The LGCP model can be fitted to data using \code{\link{kppm}}.
}
\seealso{
\code{\link{rmpoispp}},
\code{\link{rThomas}},
\code{\link{rVarGamma}},
\code{\link{rCauchy}},
\code{\link{rNeymanScott}}
}
\references{
  Jalilian, A., Guan, Y., Mateu, J. and Waagepetersen, R. (2015)
  Multivariate product‐shot‐noise Cox point process models. 
  \emph{Biometrics}  \bold{71}(4), 1022--1033.
}
\examples{
  # Example 1: homogeneous components
  lambda <- c(250, 300, 180, 400)
  kappa <- c(30, 25, 20, 25)
  omega <- c(0.02, 0.025, 0.03, 0.02)
  alpha <- matrix(runif(16, -1, 1), nrow=4, ncol=4)
  X <- rPSNCP(lambda, kappa, omega, alpha)
  plot(X)
  plot(split.ppp(X))

  #Example 2: inhomogeneous components
  lambda <- list()
  z1 <- scaletointerval.im(bei.extra$elev, from=0, to=1)
  z2 <- scaletointerval.im(bei.extra$grad, from=0, to=1)
  lambda[[1]] <- exp(-8 + 1.5 * z1 + 0.5 * z2)
  lambda[[2]] <- exp(-7.25 + 1 * z1  - 1.5 * z2)
  lambda[[3]] <- exp(-6 - 1.5 * z1 + 0.5 * z2)
  lambda[[4]] <- exp(-7.5 + 2 * z1 - 3 * z2)
  lapply(lambda, function(o){ integral.im(o) })
  kappa <- c(35, 30, 20, 25) / (1000 * 500)
  omega <- c(15, 35, 40, 25)
  alpha <- matrix(runif(16, -1, 1), nrow=4, ncol=4)
  X <- rPSNCP(lambda, kappa, omega, alpha, win = bei$window, dimyx=c(101, 201))
  plot(X)
  plot(split.ppp(X), cex=0.5) 
}
\author{Abdollah Jalilian.
  Modified by \spatstatAuthors.
}
\keyword{spatial}
\keyword{datagen}
